"use strict";(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[9162],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>g});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(a),g=r,k=u["".concat(o,".").concat(g)]||u[g]||m[g]||l;return a?n.createElement(k,i(i({ref:t},d),{},{components:a})):n.createElement(k,i({ref:t},d))}));function g(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=u;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<l;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},20458:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>p});var n=a(83117),r=(a(67294),a(3905));const l={title:"Dataset",sidebar_label:"Dataset",slug:"/metadata-ingestion/docs/transformer/dataset_transformer",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/docs/transformer/dataset_transformer.md"},i="Dataset Transformers",s={unversionedId:"metadata-ingestion/docs/transformer/dataset_transformer",id:"metadata-ingestion/docs/transformer/dataset_transformer",title:"Dataset",description:"The below table shows transformer which can transform aspects of entity Dataset.",source:"@site/genDocs/metadata-ingestion/docs/transformer/dataset_transformer.md",sourceDirName:"metadata-ingestion/docs/transformer",slug:"/metadata-ingestion/docs/transformer/dataset_transformer",permalink:"/datahub-project-forked/docs/metadata-ingestion/docs/transformer/dataset_transformer",draft:!1,editUrl:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/docs/transformer/dataset_transformer.md",tags:[],version:"current",frontMatter:{title:"Dataset",sidebar_label:"Dataset",slug:"/metadata-ingestion/docs/transformer/dataset_transformer",custom_edit_url:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/docs/transformer/dataset_transformer.md"},sidebar:"overviewSidebar",previous:{title:"Introduction",permalink:"/datahub-project-forked/docs/metadata-ingestion/docs/transformer/intro"},next:{title:"Introduction to Scheduling Metadata Ingestion",permalink:"/datahub-project-forked/docs/metadata-ingestion/schedule_docs/intro"}},o={},p=[{value:"Mark Dataset Status",id:"mark-dataset-status",level:2},{value:"Config Details",id:"config-details",level:3},{value:"Simple Add Dataset ownership",id:"simple-add-dataset-ownership",level:2},{value:"Config Details",id:"config-details-1",level:3},{value:"Pattern Add Dataset ownership",id:"pattern-add-dataset-ownership",level:2},{value:"Config Details",id:"config-details-2",level:3},{value:"Simple Remove Dataset ownership",id:"simple-remove-dataset-ownership",level:2},{value:"Simple Add Dataset globalTags",id:"simple-add-dataset-globaltags",level:2},{value:"Config Details",id:"config-details-3",level:3},{value:"Pattern Add Dataset globalTags",id:"pattern-add-dataset-globaltags",level:2},{value:"Config Details",id:"config-details-4",level:3},{value:"Add Dataset globalTags",id:"add-dataset-globaltags",level:2},{value:"Config Details",id:"config-details-5",level:3},{value:"Set Dataset browsePath",id:"set-dataset-browsepath",level:2},{value:"Config Details",id:"config-details-6",level:3},{value:"Simple Add Dataset glossaryTerms",id:"simple-add-dataset-glossaryterms",level:2},{value:"Config Details",id:"config-details-7",level:3},{value:"Pattern Add Dataset glossaryTerms",id:"pattern-add-dataset-glossaryterms",level:2},{value:"Config Details",id:"config-details-8",level:3},{value:"Pattern Add Dataset Schema Field glossaryTerms",id:"pattern-add-dataset-schema-field-glossaryterms",level:2},{value:"Config Details",id:"config-details-9",level:3},{value:"Pattern Add Dataset Schema Field globalTags",id:"pattern-add-dataset-schema-field-globaltags",level:2},{value:"Config Details",id:"config-details-10",level:3},{value:"Simple Add Dataset datasetProperties",id:"simple-add-dataset-datasetproperties",level:2},{value:"Config Details",id:"config-details-11",level:3},{value:"Add Dataset datasetProperties",id:"add-dataset-datasetproperties",level:2},{value:"Config Details",id:"config-details-12",level:3},{value:"Simple Add Dataset domains",id:"simple-add-dataset-domains",level:2},{value:"Config Details",id:"config-details-13",level:3},{value:"Pattern Add Dataset domains",id:"pattern-add-dataset-domains",level:2},{value:"Config Details",id:"config-details-14",level:3},{value:"Relationship Between replace_existing and semantics",id:"relationship-between-replace_existing-and-semantics",level:2},{value:"Writing a custom transformer from scratch",id:"writing-a-custom-transformer-from-scratch",level:2},{value:"Defining a config",id:"defining-a-config",level:3},{value:"Defining the transformer",id:"defining-the-transformer",level:3},{value:"More Sophistication: Making calls to DataHub during Transformation",id:"more-sophistication-making-calls-to-datahub-during-transformation",level:3},{value:"Advanced Use-Case: Patching Owners",id:"advanced-use-case-patching-owners",level:4},{value:"Installing the package",id:"installing-the-package",level:3},{value:"Running the transform",id:"running-the-transform",level:3}],d={toc:p};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dataset-transformers"},"Dataset Transformers"),(0,r.kt)("p",null,"The below table shows transformer which can transform aspects of entity ",(0,r.kt)("a",{parentName:"p",href:"/datahub-project-forked/docs/generated/metamodel/entities/dataset"},"Dataset"),"."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Dataset Aspect"),(0,r.kt)("th",{parentName:"tr",align:null},"Transformer"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"status")),(0,r.kt)("td",{parentName:"tr",align:null},"- ",(0,r.kt)("a",{parentName:"td",href:"#mark-dataset-status"},"Mark Dataset status"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ownership")),(0,r.kt)("td",{parentName:"tr",align:null},"- ",(0,r.kt)("a",{parentName:"td",href:"#simple-add-dataset-ownership"},"Simple Add Dataset ownership"),(0,r.kt)("br",null)," - ",(0,r.kt)("a",{parentName:"td",href:"#pattern-add-dataset-ownership"},"Pattern Add Dataset ownership"),(0,r.kt)("br",null)," - ",(0,r.kt)("a",{parentName:"td",href:"#simple-remove-dataset-ownership"},"Simple Remove Dataset Ownership"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"globalTags")),(0,r.kt)("td",{parentName:"tr",align:null},"- ",(0,r.kt)("a",{parentName:"td",href:"#simple-add-dataset-globaltags"},"Simple Add Dataset globalTags "),(0,r.kt)("br",null)," - ",(0,r.kt)("a",{parentName:"td",href:"#pattern-add-dataset-globaltags"},"Pattern Add Dataset globalTags"),(0,r.kt)("br",null)," - ",(0,r.kt)("a",{parentName:"td",href:"#add-dataset-globaltags"},"Add Dataset globalTags"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"browsePaths")),(0,r.kt)("td",{parentName:"tr",align:null},"- ",(0,r.kt)("a",{parentName:"td",href:"#set-dataset-browsepath"},"Set Dataset browsePath"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"glossaryTerms")),(0,r.kt)("td",{parentName:"tr",align:null},"- ",(0,r.kt)("a",{parentName:"td",href:"#simple-add-dataset-glossaryterms"},"Simple Add Dataset glossaryTerms "),(0,r.kt)("br",null)," - ",(0,r.kt)("a",{parentName:"td",href:"#pattern-add-dataset-glossaryterms"},"Pattern Add Dataset glossaryTerms"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"schemaMetadata")),(0,r.kt)("td",{parentName:"tr",align:null},"- ",(0,r.kt)("a",{parentName:"td",href:"#pattern-add-dataset-schema-field-glossaryterms"},"Pattern Add Dataset Schema Field glossaryTerms"),(0,r.kt)("br",null)," - ",(0,r.kt)("a",{parentName:"td",href:"#pattern-add-dataset-schema-field-globaltags"},"Pattern Add Dataset Schema Field globalTags"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"datasetProperties")),(0,r.kt)("td",{parentName:"tr",align:null},"- ",(0,r.kt)("a",{parentName:"td",href:"#simple-add-dataset-datasetproperties"},"Simple Add Dataset datasetProperties"),(0,r.kt)("br",null)," - ",(0,r.kt)("a",{parentName:"td",href:"#add-dataset-datasetproperties"},"Add Dataset datasetProperties"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"domains")),(0,r.kt)("td",{parentName:"tr",align:null},"- ",(0,r.kt)("a",{parentName:"td",href:"#simple-add-dataset-domains"},"Simple Add Dataset domains"),(0,r.kt)("br",null)," - ",(0,r.kt)("a",{parentName:"td",href:"#pattern-add-dataset-domains"},"Pattern Add Dataset domains"))))),(0,r.kt)("h2",{id:"mark-dataset-status"},"Mark Dataset Status"),(0,r.kt)("h3",{id:"config-details"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"removed")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Flag to control visbility of dataset on UI.")))),(0,r.kt)("p",null,"If you would like to stop a dataset from appearing in the UI, then you need to mark the status of the dataset as removed. "),(0,r.kt)("p",null,"You can use this transformer in your source recipe to mark status as removed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "mark_dataset_status"\n    config:\n      removed: true\n')),(0,r.kt)("h2",{id:"simple-add-dataset-ownership"},"Simple Add Dataset ownership"),(0,r.kt)("h3",{id:"config-details-1"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"owner_urns")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"list","[string]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"List of owner urns.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ownership_type")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"DATAOWNER")),(0,r.kt)("td",{parentName:"tr",align:null},"ownership type of the owners.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"For transformer behaviour on ",(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"semantics"),", please refer section ",(0,r.kt)("a",{parentName:"p",href:"#relationship-between-replace_existing-and-semantics"},"Relationship Between replace_existing And semantics"),"."),(0,r.kt)("br",null),"Let\u2019s suppose we\u2019d like to append a series of users who we know to own a dataset but aren't detected during normal ingestion. To do so, we can use the `simple_add_dataset_ownership` transformer that\u2019s included in the ingestion framework.",(0,r.kt)("p",null,"The config, which we\u2019d append to our ingestion recipe YAML, would look like this:"),(0,r.kt)("p",null,"Below configuration will add listed owner_urns in ownership aspect"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_ownership"\n    config:\n      owner_urns:\n        - "urn:li:corpuser:username1"\n        - "urn:li:corpuser:username2"\n        - "urn:li:corpGroup:groupname"\n      ownership_type: "PRODUCER"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_ownership")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add owners, however replace existing owners sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_ownership"\n    config:\n      replace_existing: true  # false is default behaviour\n      owner_urns:\n        - "urn:li:corpuser:username1"\n        - "urn:li:corpuser:username2"\n        - "urn:li:corpGroup:groupname"\n      ownership_type: "PRODUCER"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add owners, however overwrite the owners available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_ownership"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      owner_urns:\n        - "urn:li:corpuser:username1"\n        - "urn:li:corpuser:username2"\n        - "urn:li:corpGroup:groupname"\n      ownership_type: "PRODUCER"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add owners, however keep the owners available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_ownership"\n    config:\n      semantics: PATCH\n      owner_urns:\n        - "urn:li:corpuser:username1"\n        - "urn:li:corpuser:username2"\n        - "urn:li:corpGroup:groupname"\n      ownership_type: "PRODUCER"\n')))),(0,r.kt)("h2",{id:"pattern-add-dataset-ownership"},"Pattern Add Dataset ownership"),(0,r.kt)("h3",{id:"config-details-2"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"owner_pattern")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"map[regx, list","[urn]","]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"entity urn with regular expression and list of owners urn apply to matching entity urn.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ownership_type")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"string"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"DATAOWNER")),(0,r.kt)("td",{parentName:"tr",align:null},"ownership type of the owners.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"let\u2019s suppose we\u2019d like to append a series of users who we know to own a different dataset from a data source but aren't detected during normal ingestion. To do so, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_ownership")," module that\u2019s included in the ingestion framework.  This will match the pattern to ",(0,r.kt)("inlineCode",{parentName:"p"},"urn")," of the dataset and assign the respective owners."),(0,r.kt)("p",null,"The config, which we\u2019d append to our ingestion recipe YAML, would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_ownership"\n    config:\n      owner_pattern:\n        rules:\n          ".*example1.*": ["urn:li:corpuser:username1"]\n          ".*example2.*": ["urn:li:corpuser:username2"]\n      ownership_type: "DEVELOPER"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_ownership")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add owner, however replace existing owner sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_ownership"\n    config:\n      replace_existing: true  # false is default behaviour\n      owner_pattern:\n        rules:\n          ".*example1.*": ["urn:li:corpuser:username1"]\n          ".*example2.*": ["urn:li:corpuser:username2"]\n      ownership_type: "PRODUCER"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add owner, however overwrite the owners available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_ownership"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      owner_pattern:\n        rules:\n          ".*example1.*": ["urn:li:corpuser:username1"]\n          ".*example2.*": ["urn:li:corpuser:username2"]\n      ownership_type: "PRODUCER"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add owner, however keep the owners available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_ownership"\n    config:\n      semantics: PATCH\n      owner_pattern:\n        rules:\n          ".*example1.*": ["urn:li:corpuser:username1"]\n          ".*example2.*": ["urn:li:corpuser:username2"]\n      ownership_type: "PRODUCER"\n')))),(0,r.kt)("h2",{id:"simple-remove-dataset-ownership"},"Simple Remove Dataset ownership"),(0,r.kt)("p",null,"If we wanted to clear existing owners sent by ingestion source we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"simple_remove_dataset_ownership")," transformer which removes all owners sent by the ingestion source."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_remove_dataset_ownership"\n    config: {}\n')),(0,r.kt)("p",null,"The main use case of ",(0,r.kt)("inlineCode",{parentName:"p"},"simple_remove_dataset_ownership")," is to remove incorrect owners present in the source. You can use it along with the ",(0,r.kt)("a",{parentName:"p",href:"#simple-add-dataset-ownership"},"Simple Add Dataset ownership")," to remove wrong owners and add the correct ones."),(0,r.kt)("p",null,"Note that whatever owners you send via ",(0,r.kt)("inlineCode",{parentName:"p"},"simple_remove_dataset_ownership")," will overwrite the owners present in the UI."),(0,r.kt)("h2",{id:"simple-add-dataset-globaltags"},"Simple Add Dataset globalTags"),(0,r.kt)("h3",{id:"config-details-3"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tag_urns")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"list","[string]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"List of globalTags urn.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"Let\u2019s suppose we\u2019d like to add a set of dataset tags. To do so, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_tags")," transformer that\u2019s included in the ingestion framework."),(0,r.kt)("p",null,"The config, which we\u2019d append to our ingestion recipe YAML, would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_tags"\n    config:\n      tag_urns:\n        - "urn:li:tag:NeedsDocumentation"\n        - "urn:li:tag:Legacy"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_tags")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add tags, however replace existing tags sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_tags"\n    config:\n      replace_existing: true  # false is default behaviour\n      tag_urns:\n        - "urn:li:tag:NeedsDocumentation"\n        - "urn:li:tag:Legacy"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add tags, however overwrite the tags available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_tags"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      tag_urns:\n        - "urn:li:tag:NeedsDocumentation"\n        - "urn:li:tag:Legacy"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add tags, however keep the tags available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_tags"\n    config:\n      semantics: PATCH\n      tag_urns:\n        - "urn:li:tag:NeedsDocumentation"\n        - "urn:li:tag:Legacy"\n')))),(0,r.kt)("h2",{id:"pattern-add-dataset-globaltags"},"Pattern Add Dataset globalTags"),(0,r.kt)("h3",{id:"config-details-4"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tag_pattern")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"map[regx, list","[urn]","]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Entity urn with regular expression and list of tags urn apply to matching entity urn.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"Let\u2019s suppose we\u2019d like to append a series of tags to specific datasets. To do so, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_tags")," module that\u2019s included in the ingestion framework.  This will match the regex pattern to ",(0,r.kt)("inlineCode",{parentName:"p"},"urn")," of the dataset and assign the respective tags urns given in the array."),(0,r.kt)("p",null,"The config, which we\u2019d append to our ingestion recipe YAML, would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_tags"\n    config:\n      tag_pattern:\n        rules:\n          ".*example1.*": ["urn:li:tag:NeedsDocumentation", "urn:li:tag:Legacy"]\n          ".*example2.*": ["urn:li:tag:NeedsDocumentation"]\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_tags")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add tags, however replace existing tags sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_tags"\n    config:\n      replace_existing: true  # false is default behaviour\n      tag_pattern:\n        rules:\n          ".*example1.*": ["urn:li:tag:NeedsDocumentation", "urn:li:tag:Legacy"]\n          ".*example2.*": ["urn:li:tag:NeedsDocumentation"]\n'))),(0,r.kt)("li",{parentName:"ul"},"Add tags, however overwrite the tags available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_tags"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      tag_pattern:\n        rules:\n          ".*example1.*": ["urn:li:tag:NeedsDocumentation", "urn:li:tag:Legacy"]\n          ".*example2.*": ["urn:li:tag:NeedsDocumentation"]\n'))),(0,r.kt)("li",{parentName:"ul"},"Add tags, however keep the tags available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_tags"\n    config:\n      semantics: PATCH\n      tag_pattern:\n        rules:\n          ".*example1.*": ["urn:li:tag:NeedsDocumentation", "urn:li:tag:Legacy"]\n          ".*example2.*": ["urn:li:tag:NeedsDocumentation"]\n')))),(0,r.kt)("h2",{id:"add-dataset-globaltags"},"Add Dataset globalTags"),(0,r.kt)("h3",{id:"config-details-5"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"get_tags_to_add")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"callable[","[str]",", list","[TagAssociationClass]","]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"A function which takes entity urn as input and return TagAssociationClass.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"If you'd like to add more complex logic for assigning tags, you can use the more generic add_dataset_tags transformer, which calls a user-provided function to determine the tags for each dataset."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "add_dataset_tags"\n    config:\n      get_tags_to_add: "<your_module>.<your_function>"\n')),(0,r.kt)("p",null,"Then define your function to return a list of TagAssociationClass tags, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'import logging\n\nimport datahub.emitter.mce_builder as builder\nfrom datahub.metadata.schema_classes import (\n    TagAssociationClass\n)\n\ndef custom_tags(entity_urn: str) -> List[TagAssociationClass]:\n    """Compute the tags to associate to a given dataset."""\n\n    tag_strings = []\n\n    ### Add custom logic here\n    tag_strings.append(\'custom1\')\n    tag_strings.append(\'custom2\')\n    \n    tag_strings = [builder.make_tag_urn(tag=n) for n in tag_strings]\n    tags = [TagAssociationClass(tag=tag) for tag in tag_strings]\n    \n    logging.info(f"Tagging dataset {entity_urn} with {tag_strings}.")\n    return tags\n')),(0,r.kt)("p",null,"Finally, you can install and use your custom transformer as ",(0,r.kt)("a",{parentName:"p",href:"#installing-the-package"},"shown here"),"."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add_dataset_tags")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add tags, however replace existing tags sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "add_dataset_tags"\n    config:\n      replace_existing: true  # false is default behaviour\n      get_tags_to_add: "<your_module>.<your_function>"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add tags, however overwrite the tags available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "add_dataset_tags"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      get_tags_to_add: "<your_module>.<your_function>"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add tags, however keep the tags available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "add_dataset_tags"\n    config:\n      semantics: PATCH\n      get_tags_to_add: "<your_module>.<your_function>"\n')))),(0,r.kt)("h2",{id:"set-dataset-browsepath"},"Set Dataset browsePath"),(0,r.kt)("h3",{id:"config-details-6"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"path_templates")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"list","[string]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"List of path templates.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"If you would like to add to browse paths of dataset can use this transformer. There are 3 optional variables that you can use to get information from the dataset ",(0,r.kt)("inlineCode",{parentName:"p"},"urn"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ENV: env passed (default: prod)"),(0,r.kt)("li",{parentName:"ul"},"PLATFORM: ",(0,r.kt)("inlineCode",{parentName:"li"},"mysql"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"postgres")," or different platform supported by datahub"),(0,r.kt)("li",{parentName:"ul"},"DATASET_PARTS: slash separated parts of dataset name. e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"database_name/schema_name/[table_name]")," for postgres")),(0,r.kt)("p",null,"e.g. this can be used to create browse paths like ",(0,r.kt)("inlineCode",{parentName:"p"},"/prod/postgres/superset/public/logs")," for table ",(0,r.kt)("inlineCode",{parentName:"p"},"superset.public.logs")," in a ",(0,r.kt)("inlineCode",{parentName:"p"},"postgres")," database"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "set_dataset_browse_path"\n    config:\n      path_templates:\n        - /ENV/PLATFORM/DATASET_PARTS \n')),(0,r.kt)("p",null,"If you don't want the environment but wanted to add something static in the browse path like the database instance name you can use this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "set_dataset_browse_path"\n    config:\n      path_templates:\n        - /PLATFORM/marketing_db/DATASET_PARTS \n')),(0,r.kt)("p",null,"It will create browse path like ",(0,r.kt)("inlineCode",{parentName:"p"},"/mysql/marketing_db/sales/orders")," for a table ",(0,r.kt)("inlineCode",{parentName:"p"},"sales.orders")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"mysql")," database instance."),(0,r.kt)("p",null,"You can use this to add multiple browse paths. Different people might know the same data assets by different names."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "set_dataset_browse_path"\n    config:\n      path_templates:\n        - /PLATFORM/marketing_db/DATASET_PARTS\n        - /data_warehouse/DATASET_PARTS\n')),(0,r.kt)("p",null,"This will add 2 browse paths like ",(0,r.kt)("inlineCode",{parentName:"p"},"/mysql/marketing_db/sales/orders")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"/data_warehouse/sales/orders")," for a table ",(0,r.kt)("inlineCode",{parentName:"p"},"sales.orders")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"mysql")," database instance."),(0,r.kt)("p",null,"Default behaviour of the transform is to add new browse paths, you can optionally set ",(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing: True")," so\nthe transform becomes a ",(0,r.kt)("em",{parentName:"p"},"set")," operation instead of an ",(0,r.kt)("em",{parentName:"p"},"append"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "set_dataset_browse_path"\n    config:\n      replace_existing: True\n      path_templates:\n        - /ENV/PLATFORM/DATASET_PARTS\n')),(0,r.kt)("p",null,"In this case, the resulting dataset will have only 1 browse path, the one from the transform."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"set_dataset_browse_path")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add browsePath, however replace existing browsePath sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "set_dataset_browse_path"\n    config:\n      replace_existing: true  # false is default behaviour\n      path_templates:\n        - /PLATFORM/marketing_db/DATASET_PARTS \n'))),(0,r.kt)("li",{parentName:"ul"},"Add browsePath, however overwrite the browsePath available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "set_dataset_browse_path"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      path_templates:\n        - /PLATFORM/marketing_db/DATASET_PARTS \n'))),(0,r.kt)("li",{parentName:"ul"},"Add browsePath, however keep the browsePath available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "set_dataset_browse_path"\n    config:\n      semantics: PATCH\n      path_templates:\n        - /PLATFORM/marketing_db/DATASET_PARTS \n')))),(0,r.kt)("h2",{id:"simple-add-dataset-glossaryterms"},"Simple Add Dataset glossaryTerms"),(0,r.kt)("h3",{id:"config-details-7"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"term_urns")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"list","[string]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"List of glossaryTerms urn.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"We can use a similar convention to associate ",(0,r.kt)("a",{parentName:"p",href:"/datahub-project-forked/docs/generated/ingestion/sources/business-glossary"},"Glossary Terms")," to datasets.\nWe can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_terms")," transformer that\u2019s included in the ingestion framework."),(0,r.kt)("p",null,"The config, which we\u2019d append to our ingestion recipe YAML, would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_terms"\n    config:\n      term_urns:\n        - "urn:li:glossaryTerm:Email"\n        - "urn:li:glossaryTerm:Address"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_terms")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add terms, however replace existing terms sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_terms"\n    config:\n      replace_existing: true  # false is default behaviour\n      term_urns:\n        - "urn:li:glossaryTerm:Email"\n        - "urn:li:glossaryTerm:Address"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add terms, however overwrite the terms available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_terms"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      term_urns:\n        - "urn:li:glossaryTerm:Email"\n        - "urn:li:glossaryTerm:Address"\n'))),(0,r.kt)("li",{parentName:"ul"},"Add terms, however keep the terms available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_terms"\n    config:\n      semantics: PATCH\n      term_urns:\n        - "urn:li:glossaryTerm:Email"\n        - "urn:li:glossaryTerm:Address"\n')))),(0,r.kt)("h2",{id:"pattern-add-dataset-glossaryterms"},"Pattern Add Dataset glossaryTerms"),(0,r.kt)("h3",{id:"config-details-8"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"term_pattern")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"map[regx, list","[urn]","]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"entity urn with regular expression and list of glossaryTerms urn apply to matching entity urn.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"We can add glossary terms to datasets based on a regex filter."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_terms"\n    config:\n      term_pattern:\n        rules:\n          ".*example1.*": ["urn:li:glossaryTerm:Email", "urn:li:glossaryTerm:Address"]\n          ".*example2.*": ["urn:li:glossaryTerm:PostalCode"]\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_terms")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add terms, however replace existing terms sent by ingestion source"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_terms"\n    config:\n      replace_existing: true  # false is default behaviour\n      term_pattern:\n        rules:\n          ".*example1.*": ["urn:li:glossaryTerm:Email", "urn:li:glossaryTerm:Address"]\n          ".*example2.*": ["urn:li:glossaryTerm:PostalCode"]\n\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add terms, however overwrite the terms available for the dataset on DataHub GMS"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_terms"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      term_pattern:\n        rules:\n          ".*example1.*": ["urn:li:glossaryTerm:Email", "urn:li:glossaryTerm:Address"]\n          ".*example2.*": ["urn:li:glossaryTerm:PostalCode"]\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add terms, however keep the terms available for the dataset on DataHub GMS"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_terms"\n    config:\n      semantics: PATCH\n      term_pattern:\n        rules:\n          ".*example1.*": ["urn:li:glossaryTerm:Email", "urn:li:glossaryTerm:Address"]\n          ".*example2.*": ["urn:li:glossaryTerm:PostalCode"]\n')))),(0,r.kt)("h2",{id:"pattern-add-dataset-schema-field-glossaryterms"},"Pattern Add Dataset Schema Field glossaryTerms"),(0,r.kt)("h3",{id:"config-details-9"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"term_pattern")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"map[regx, list","[urn]","]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"entity urn with regular expression and list of glossaryTerms urn apply to matching entity urn.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"We can add glossary terms to schema fields based on a regex filter."),(0,r.kt)("p",null,"Note that only terms from the first matching pattern will be applied."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_schema_terms"\n    config:\n      term_pattern:\n        rules:\n          ".*email.*": ["urn:li:glossaryTerm:Email"]\n          ".*name.*": ["urn:li:glossaryTerm:Name"]\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_schema_terms")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add terms, however replace existing terms sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_schema_terms"\n    config:\n      replace_existing: true  # false is default behaviour\n      term_pattern:\n        rules:\n          ".*email.*": ["urn:li:glossaryTerm:Email"]\n          ".*name.*": ["urn:li:glossaryTerm:Name"]\n'))),(0,r.kt)("li",{parentName:"ul"},"Add terms, however overwrite the terms available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_schema_terms"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      term_pattern:\n        rules:\n          ".*email.*": ["urn:li:glossaryTerm:Email"]\n          ".*name.*": ["urn:li:glossaryTerm:Name"]\n'))),(0,r.kt)("li",{parentName:"ul"},"Add terms, however keep the terms available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_schema_terms"\n    config:\n      semantics: PATCH\n      term_pattern:\n        rules:\n          ".*email.*": ["urn:li:glossaryTerm:Email"]\n          ".*name.*": ["urn:li:glossaryTerm:Name"]\n')))),(0,r.kt)("h2",{id:"pattern-add-dataset-schema-field-globaltags"},"Pattern Add Dataset Schema Field globalTags"),(0,r.kt)("h3",{id:"config-details-10"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"tag_pattern")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"map[regx, list","[urn]","]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"entity urn with regular expression and list of tags urn apply to matching entity urn.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"We can also append a series of tags to specific schema fields. To do so, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_schema_tags")," transformer. This will match the regex pattern to each schema field path and assign the respective tags urns given in the array."),(0,r.kt)("p",null,"Note that the tags from the first matching pattern will be applied, not all matching patterns."),(0,r.kt)("p",null,"The config would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_schema_tags"\n    config:\n      tag_pattern:\n        rules:\n          ".*email.*": ["urn:li:tag:Email"]\n          ".*name.*": ["urn:li:tag:Name"]\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_schema_tags")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add tags, however replace existing tag sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_schema_tags"\n    config:\n      replace_existing: true  # false is default behaviour\n      tag_pattern:\n        rules:\n          ".*example1.*": ["urn:li:tag:NeedsDocumentation", "urn:li:tag:Legacy"]\n          ".*example2.*": ["urn:li:tag:NeedsDocumentation"]\n'))),(0,r.kt)("li",{parentName:"ul"},"Add tags, however overwrite the tags available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_schema_tags"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      tag_pattern:\n        rules:\n          ".*example1.*": ["urn:li:tag:NeedsDocumentation", "urn:li:tag:Legacy"]\n          ".*example2.*": ["urn:li:tag:NeedsDocumentation"]\n'))),(0,r.kt)("li",{parentName:"ul"},"Add tags, however keep the tags available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "pattern_add_dataset_schema_tags"\n    config:\n      semantics: PATCH\n      tag_pattern:\n        rules:\n          ".*example1.*": ["urn:li:tag:NeedsDocumentation", "urn:li:tag:Legacy"]\n          ".*example2.*": ["urn:li:tag:NeedsDocumentation"]\n')))),(0,r.kt)("h2",{id:"simple-add-dataset-datasetproperties"},"Simple Add Dataset datasetProperties"),(0,r.kt)("h3",{id:"config-details-11"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"properties")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"dict","[str, str]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"Map of key value pair.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_properties")," transformer assigns the properties to dataset entity from the configuration.\n",(0,r.kt)("inlineCode",{parentName:"p"},"properties")," field is a dictionary of string values. Note in case of any key collision, the value in the config will\noverwrite the previous value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_properties"\n    config:\n      properties:\n        prop1: value1\n        prop2: value2\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_properties")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add dataset-properties, however replace existing dataset-properties sent by ingestion source",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_properties"\n    config:\n      replace_existing: true  # false is default behaviour\n      properties:\n        prop1: value1\n        prop2: value2\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"```\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add dataset-properties, however overwrite the dataset-properties available for the dataset on DataHub GMS",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_properties"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      properties:\n        prop1: value1\n        prop2: value2\n')))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"```\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add dataset-properties, however keep the dataset-properties available for the dataset on DataHub GMS"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_properties"\n    config:\n      semantics: PATCH\n      properties:\n        prop1: value1\n        prop2: value2\n\n')))),(0,r.kt)("h2",{id:"add-dataset-datasetproperties"},"Add Dataset datasetProperties"),(0,r.kt)("h3",{id:"config-details-12"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"add_properties_resolver_class")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"Type","[AddDatasetPropertiesResolverBase]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"A class extends from ",(0,r.kt)("inlineCode",{parentName:"td"},"AddDatasetPropertiesResolverBase"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"If you'd like to add more complex logic for assigning properties, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"add_dataset_properties")," transformer, which calls a user-provided class (that extends from ",(0,r.kt)("inlineCode",{parentName:"p"},"AddDatasetPropertiesResolverBase")," class) to determine the properties for each dataset."),(0,r.kt)("p",null,"The config, which we\u2019d append to our ingestion recipe YAML, would look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "add_dataset_properties"\n    config:\n      add_properties_resolver_class: "<your_module>.<your_class>"\n')),(0,r.kt)("p",null,"Then define your class to return a list of custom properties, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"import logging\nfrom typing import Dict\nfrom datahub.ingestion.transformer.add_dataset_properties import AddDatasetPropertiesResolverBase\n\nclass MyPropertiesResolver(AddDatasetPropertiesResolverBase):\n    def get_properties_to_add(self, entity_urn: str) -> Dict[str, str]:\n        ### Add custom logic here        \n        properties= {'my_custom_property': 'property value'}\n        logging.info(f\"Adding properties: {properties} to dataset: {entity_urn}.\")\n        return properties\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"add_dataset_properties")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add dataset-properties, however replace existing dataset-properties sent by ingestion source"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "add_dataset_properties"\n    config:\n      replace_existing: true  # false is default behaviour\n      add_properties_resolver_class: "<your_module>.<your_class>"\n\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add dataset-properties, however overwrite the dataset-properties available for the dataset on DataHub GMS"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "add_dataset_properties"\n    config:\n      semantics: OVERWRITE  # OVERWRITE is default behaviour \n      add_properties_resolver_class: "<your_module>.<your_class>"\n\n'))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Add dataset-properties, however keep the dataset-properties available for the dataset on DataHub GMS"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "add_dataset_properties"\n    config:\n      semantics: PATCH\n      add_properties_resolver_class: "<your_module>.<your_class>"\n')))),(0,r.kt)("h2",{id:"simple-add-dataset-domains"},"Simple Add Dataset domains"),(0,r.kt)("h3",{id:"config-details-13"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"domains")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"list[union","[urn, str]","]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"List of simple domain name or domain urns.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"For transformer behaviour on ",(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"semantics"),", please refer section ",(0,r.kt)("a",{parentName:"p",href:"#relationship-between-replace_existing-and-semantics"},"Relationship Between replace_existing And semantics"),"."),(0,r.kt)("br",null),(0,r.kt)("p",null,"let\u2019s suppose we\u2019d like to add a series of domain to dataset, in this case you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_domain")," transformer."),(0,r.kt)("p",null,"The config, which we\u2019d append to our ingestion recipe YAML, would look like this:"),(0,r.kt)("p",null,"Here we can set domains to either urn (i.e. urn:li:domain:engineering) or simple domain name (i.e. engineering) in both of the cases domain should be provisioned on DataHub GMS"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "simple_add_dataset_domain"\n    config:\n      semantics: OVERWRITE\n      domains:\n        - urn:li:domain:engineering\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_domain")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add domains, however replace existing domains sent by ingestion source")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'    transformers:\n      - type: "simple_add_dataset_domain"\n        config:\n          replace_existing: true  # false is default behaviour\n          domains:\n            - "urn:li:domain:engineering"\n            - "urn:li:domain:hr"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add domains, however overwrite the domains available for the dataset on DataHub GMS")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'    transformers:\n      - type: "simple_add_dataset_domain"\n        config:\n          semantics: OVERWRITE  # OVERWRITE is default behaviour \n          domains:\n            - "urn:li:domain:engineering"\n            - "urn:li:domain:hr"\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add domains, however keep the domains available for the dataset on DataHub GMS")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'    transformers:\n      - type: "simple_add_dataset_domain"\n        config:\n          semantics: PATCH\n          domains:\n            - "urn:li:domain:engineering"\n            - "urn:li:domain:hr"\n')),(0,r.kt)("h2",{id:"pattern-add-dataset-domains"},"Pattern Add Dataset domains"),(0,r.kt)("h3",{id:"config-details-14"},"Config Details"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Field"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Default"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"domain_pattern")),(0,r.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:null},"map[regx, list[union","[urn, str]","]"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"dataset urn with regular expression and list of simple domain name or domain urn need to be apply on matching dataset urn.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"replace_existing")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"false")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to remove owners from entity sent by ingestion source.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"semantics")),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"enum"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"OVERWRITE")),(0,r.kt)("td",{parentName:"tr",align:null},"Whether to OVERWRITE or PATCH the entity present on DataHub GMS.")))),(0,r.kt)("p",null,"Let\u2019s suppose we\u2019d like to append a series of domain to specific datasets. To do so, we can use the pattern_add_dataset_domain transformer that\u2019s included in the ingestion framework.\nThis will match the regex pattern to urn of the dataset and assign the respective domain urns given in the array."),(0,r.kt)("p",null,"The config, which we\u2019d append to our ingestion recipe YAML, would look like this:\nHere we can set domain list to either urn (i.e. urn:li:domain:hr) or simple domain name (i.e. hr)\nin both of the cases domain should be provisioned on DataHub GMS"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'  transformers:\n    - type: "pattern_add_dataset_domain"\n      config:\n        semantics: OVERWRITE\n        domain_pattern:\n          rules:\n            \'urn:li:dataset:\\(urn:li:dataPlatform:postgres,postgres\\.public\\.n.*\': ["hr"]\n            \'urn:li:dataset:\\(urn:li:dataPlatform:postgres,postgres\\.public\\.t.*\': ["urn:li:domain:finance"]\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"pattern_add_dataset_domain")," can be configured in below different way "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add domains, however replace existing domains sent by ingestion source")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'    transformers:\n      - type: "pattern_add_dataset_ownership"\n        config:\n          replace_existing: true  # false is default behaviour\n          domain_pattern:\n            rules:\n              \'urn:li:dataset:\\(urn:li:dataPlatform:postgres,postgres\\.public\\.n.*\': ["hr"]\n              \'urn:li:dataset:\\(urn:li:dataPlatform:postgres,postgres\\.public\\.t.*\': ["urn:li:domain:finance"] \n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add domains, however overwrite the domains available for the dataset on DataHub GMS")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'      transformers:\n        - type: "pattern_add_dataset_ownership"\n          config:\n            semantics: OVERWRITE  # OVERWRITE is default behaviour \n            domain_pattern:\n              rules:\n                \'urn:li:dataset:\\(urn:li:dataPlatform:postgres,postgres\\.public\\.n.*\': ["hr"]\n                \'urn:li:dataset:\\(urn:li:dataPlatform:postgres,postgres\\.public\\.t.*\': ["urn:li:domain:finance"] \n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add domains, however keep the domains available for the dataset on DataHub GMS")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'      transformers:\n        - type: "pattern_add_dataset_ownership"\n          config:\n            semantics: PATCH\n            domain_pattern:\n              rules:\n                \'urn:li:dataset:\\(urn:li:dataPlatform:postgres,postgres\\.public\\.n.*\': ["hr"]\n                \'urn:li:dataset:\\(urn:li:dataPlatform:postgres,postgres\\.public\\.t.*\': ["urn:li:domain:finance"] \n')),(0,r.kt)("h2",{id:"relationship-between-replace_existing-and-semantics"},"Relationship Between replace_existing and semantics"),(0,r.kt)("p",null,"The transformer behaviour mentioned here is in context of ",(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_ownership"),", however it is applicable for all dataset transformers which are supporting ",(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"semantics")," configuration attributes, for example ",(0,r.kt)("inlineCode",{parentName:"p"},"simple_add_dataset_tags")," will add or remove tags as per behaviour mentioned in this section."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing"),"  controls whether to remove owners from currently executing ingestion pipeline."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"semantics")," controls whether to overwrite or patch owners present on DataHub GMS server. These owners might be added from DataHub Portal."),(0,r.kt)("p",null,"if ",(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"semantics")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"OVERWRITE")," then transformer takes below steps"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"As ",(0,r.kt)("inlineCode",{parentName:"li"},"replace_existing")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),", remove the owners from input entity (i.e. dataset)"),(0,r.kt)("li",{parentName:"ol"},"Add owners mentioned in ingestion recipe to input entity  "),(0,r.kt)("li",{parentName:"ol"},"As ",(0,r.kt)("inlineCode",{parentName:"li"},"semantics")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"OVERWRITE")," no need to fetch owners present on DataHub GMS server for the input entity"),(0,r.kt)("li",{parentName:"ol"},"Return input entity ")),(0,r.kt)("p",null,"if ",(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"semantics")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"PATCH")," then transformer takes below steps"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"replace_existing")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"true"),", first remove the owners from input entity (i.e. dataset)"),(0,r.kt)("li",{parentName:"ol"},"Add owners mentioned in ingestion recipe to input entity  "),(0,r.kt)("li",{parentName:"ol"},"As ",(0,r.kt)("inlineCode",{parentName:"li"},"semantics")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"PATCH")," fetch owners for the input entity from DataHub GMS Server"),(0,r.kt)("li",{parentName:"ol"},"Add owners fetched from DataHub GMS Server to input entity"),(0,r.kt)("li",{parentName:"ol"},"Return input entity ")),(0,r.kt)("p",null,"if ",(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"semantics")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"OVERWRITE")," then transformer takes below steps"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"As ",(0,r.kt)("inlineCode",{parentName:"li"},"replace_existing")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),", keep the owners present in input entity as is"),(0,r.kt)("li",{parentName:"ol"},"Add owners mentioned in ingestion recipe to input entity  "),(0,r.kt)("li",{parentName:"ol"},"As ",(0,r.kt)("inlineCode",{parentName:"li"},"semantics")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"OVERWRITE")," no need to fetch owners from DataHub GMS Server for the input entity"),(0,r.kt)("li",{parentName:"ol"},"Return input entity ")),(0,r.kt)("p",null,"if ",(0,r.kt)("inlineCode",{parentName:"p"},"replace_existing")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"semantics")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"PATCH")," then transformer takes below steps"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"replace_existing")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"false"),", keep the owners present in input entity as is"),(0,r.kt)("li",{parentName:"ol"},"Add owners mentioned in ingestion recipe to input entity  "),(0,r.kt)("li",{parentName:"ol"},"As ",(0,r.kt)("inlineCode",{parentName:"li"},"semantics")," is set to ",(0,r.kt)("inlineCode",{parentName:"li"},"PATCH")," fetch owners for the input entity from DataHub GMS Server"),(0,r.kt)("li",{parentName:"ol"},"Add owners fetched from DataHub GMS Server to input entity"),(0,r.kt)("li",{parentName:"ol"},"Return input entity ")),(0,r.kt)("h2",{id:"writing-a-custom-transformer-from-scratch"},"Writing a custom transformer from scratch"),(0,r.kt)("p",null,"In the above couple of examples, we use classes that have already been implemented in the ingestion framework. However, it\u2019s common for more advanced cases to pop up where custom code is required, for instance if you'd like to utilize conditional logic or rewrite properties. In such cases, we can add our own modules and define the arguments it takes as a custom transformer."),(0,r.kt)("p",null,"As an example, suppose we want to append a set of ownership fields to our metadata that are dependent upon an external source \u2013 for instance, an API endpoint or file \u2013 rather than a preset list like above. In this case, we can set a JSON file as an argument to our custom config, and our transformer will read this file and append the included ownership elements to all metadata events."),(0,r.kt)("p",null,"Our JSON file might look like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'[\n  "urn:li:corpuser:athos",\n  "urn:li:corpuser:porthos",\n  "urn:li:corpuser:aramis",\n  "urn:li:corpGroup:the_three_musketeers"\n]\n')),(0,r.kt)("h3",{id:"defining-a-config"},"Defining a config"),(0,r.kt)("p",null,"To get started, we\u2019ll initiate an ",(0,r.kt)("inlineCode",{parentName:"p"},"AddCustomOwnershipConfig")," class that inherits from ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/configuration/common.py"},(0,r.kt)("inlineCode",{parentName:"a"},"datahub.configuration.common.ConfigModel")),". The sole parameter will be an ",(0,r.kt)("inlineCode",{parentName:"p"},"owners_json")," which expects a path to a JSON file containing a list of owner URNs. This will go in a file called ",(0,r.kt)("inlineCode",{parentName:"p"},"custom_transform_example.py"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"from datahub.configuration.common import ConfigModel\n\nclass AddCustomOwnershipConfig(ConfigModel):\n    owners_json: str\n")),(0,r.kt)("h3",{id:"defining-the-transformer"},"Defining the transformer"),(0,r.kt)("p",null,"Next, we\u2019ll define the transformer itself, which must inherit from ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/api/transform.py"},(0,r.kt)("inlineCode",{parentName:"a"},"datahub.ingestion.api.transform.Transformer")),". The framework provides a helper class called ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/src/datahub/ingestion/transformer/base_transformer.py"},(0,r.kt)("inlineCode",{parentName:"a"},"datahub.ingestion.transformer.base_transformer.BaseTransformer"))," that makes it super-simple to write transformers.\nFirst, let's get all our imports in:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# append these to the start of custom_transform_example.py\nimport json\nfrom typing import List, Optional\n\nfrom datahub.configuration.common import ConfigModel\nfrom datahub.ingestion.api.common import PipelineContext\nfrom datahub.ingestion.transformer.add_dataset_ownership import Semantics\nfrom datahub.ingestion.transformer.base_transformer import (\n    BaseTransformer,\n    SingleAspectTransformer,\n)\nfrom datahub.metadata.schema_classes import (\n    OwnerClass,\n    OwnershipClass,\n    OwnershipTypeClass,\n)\n\n")),(0,r.kt)("p",null,"Next, let's define the base scaffolding for the class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# append this to the end of custom_transform_example.py\n\nclass AddCustomOwnership(BaseTransformer, SingleAspectTransformer):\n    """Transformer that adds owners to datasets according to a callback function."""\n\n    # context param to generate run metadata such as a run ID\n    ctx: PipelineContext\n    # as defined in the previous block\n    config: AddCustomOwnershipConfig\n\n    def __init__(self, config: AddCustomOwnershipConfig, ctx: PipelineContext):\n        super().__init__()\n        self.ctx = ctx\n        self.config = config\n\n        with open(self.config.owners_json, "r") as f:\n            raw_owner_urns = json.load(f)\n\n        self.owners = [\n            OwnerClass(owner=owner, type=OwnershipTypeClass.DATAOWNER)\n            for owner in raw_owner_urns\n        ]\n')),(0,r.kt)("p",null,"A transformer must have two functions: a ",(0,r.kt)("inlineCode",{parentName:"p"},"create()")," function for initialization and a ",(0,r.kt)("inlineCode",{parentName:"p"},"transform()")," function for executing the transformation. Transformers that extend ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseTransformer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SingleAspectTransformer")," can avoid having to implement the more complex ",(0,r.kt)("inlineCode",{parentName:"p"},"transform")," function and just implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"transform_aspect")," function."),(0,r.kt)("p",null,"Let's begin by adding a ",(0,r.kt)("inlineCode",{parentName:"p"},"create()")," method for parsing our configuration dictionary:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# add this as a function of AddCustomOwnership\n\n@classmethod\ndef create(cls, config_dict: dict, ctx: PipelineContext) -> "AddCustomOwnership":\n  config = AddCustomOwnershipConfig.parse_obj(config_dict)\n  return cls(config, ctx)\n')),(0,r.kt)("p",null,"Next we need to tell the helper classes which entity types and aspect we are interested in transforming. In this case, we want to only process ",(0,r.kt)("inlineCode",{parentName:"p"},"dataset")," entities and transform the ",(0,r.kt)("inlineCode",{parentName:"p"},"ownership")," aspect."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def entity_types(self) -> List[str]:\n        return ["dataset"]\n\n    def aspect_name(self) -> str:\n        return "ownership"\n')),(0,r.kt)("p",null,"Finally we need to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"transform_aspect()")," method that does the work of adding our custom ownership classes. This method will be called be the framework with an optional aspect value filled out if the upstream source produced a value for this aspect. The framework takes care of pre-processing both MCE-s and MCP-s so that the ",(0,r.kt)("inlineCode",{parentName:"p"},"transform_aspect()")," function is only called one per entity. Our job is merely to inspect the incoming aspect (or absence) and produce a transformed value for this aspect. Returning ",(0,r.kt)("inlineCode",{parentName:"p"},"None")," from this method will effectively suppress this aspect from being emitted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"# add this as a function of AddCustomOwnership\n\n  def transform_aspect(  # type: ignore\n      self, entity_urn: str, aspect_name: str, aspect: Optional[OwnershipClass]\n  ) -> Optional[OwnershipClass]:\n\n      owners_to_add = self.owners\n      assert aspect is None or isinstance(aspect, OwnershipClass)\n\n      if owners_to_add:\n          ownership = (\n              aspect\n              if aspect\n              else OwnershipClass(\n                  owners=[],\n              )\n          )\n          ownership.owners.extend(owners_to_add)\n\n      return ownership\n")),(0,r.kt)("h3",{id:"more-sophistication-making-calls-to-datahub-during-transformation"},"More Sophistication: Making calls to DataHub during Transformation"),(0,r.kt)("p",null,"In some advanced cases, you might want to check with DataHub before performing a transformation. A good example for this might be retrieving the current set of owners of a dataset before providing the new set of owners during an ingestion process. To allow transformers to always be able to query the graph, the framework provides them access to the graph through the context object ",(0,r.kt)("inlineCode",{parentName:"p"},"ctx"),". Connectivity to the graph is automatically instantiated anytime the pipeline uses a REST sink. In case you are using the Kafka sink, you can additionally provide access to the graph by configuring it in your pipeline. "),(0,r.kt)("p",null,"Here is an example of a recipe that uses Kafka as the sink, but provides access to the graph by explicitly configuring the ",(0,r.kt)("inlineCode",{parentName:"p"},"datahub_api"),". "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'source:\n  type: mysql\n  config: \n     # ..source configs\n     \nsink: \n  type: datahub-kafka\n  config:\n     connection:\n        bootstrap: localhost:9092\n    schema_registry_url: "http://localhost:8081"\n\ndatahub_api:\n  server: http://localhost:8080\n  # standard configs accepted by datahub rest client ... \n')),(0,r.kt)("h4",{id:"advanced-use-case-patching-owners"},"Advanced Use-Case: Patching Owners"),(0,r.kt)("p",null,"With the above capability, we can now build more powerful transformers that can check with the server-side state before issuing changes in metadata.\ne.g. Here is how the AddDatasetOwnership transformer can now support PATCH semantics by ensuring that it never deletes any owners that are stored on the server. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def transform_one(self, mce: MetadataChangeEventClass) -> MetadataChangeEventClass:\n        if not isinstance(mce.proposedSnapshot, DatasetSnapshotClass):\n            return mce\n        owners_to_add = self.config.get_owners_to_add(mce.proposedSnapshot)\n        if owners_to_add:\n            ownership = builder.get_or_add_aspect(\n                mce,\n                OwnershipClass(\n                    owners=[],\n                ),\n            )\n            ownership.owners.extend(owners_to_add)\n\n            if self.config.semantics == Semantics.PATCH:\n                assert self.ctx.graph\n                patch_ownership = AddDatasetOwnership.get_ownership_to_set(\n                    self.ctx.graph, mce.proposedSnapshot.urn, ownership\n                )\n                builder.set_aspect(\n                    mce, aspect=patch_ownership, aspect_type=OwnershipClass\n                )\n        return mce\n")),(0,r.kt)("h3",{id:"installing-the-package"},"Installing the package"),(0,r.kt)("p",null,"Now that we've defined the transformer, we need to make it visible to DataHub. The easiest way to do this is to just place it in the same directory as your recipe, in which case the module name is the same as the file \u2013 in this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"custom_transform_example"),"."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Advanced: Installing as a package and enable discoverability"),"Alternatively, create a `setup.py` in the same directory as our transform script to make it visible globally. After installing this package (e.g. with `python setup.py` or `pip install -e .`), our module will be installed and importable as `custom_transform_example`.",(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from setuptools import find_packages, setup\n\nsetup(\n    name="custom_transform_example",\n    version="1.0",\n    packages=find_packages(),\n    # if you don\'t already have DataHub installed, add it under install_requires\n    # install_requires=["acryl-datahub"],\n    entry_points={\n        "datahub.ingestion.transformer.plugins": [\n            "custom_transform_example_alias = custom_transform_example:AddCustomOwnership",\n        ],\n    },\n)\n')),(0,r.kt)("p",null,"Additionally, declare the transformer under the ",(0,r.kt)("inlineCode",{parentName:"p"},"entry_points")," variable of the setup script. This enables the transformer to be\nlisted when running ",(0,r.kt)("inlineCode",{parentName:"p"},"datahub check plugins"),", and sets up the transformer's shortened alias for use in recipes.")),(0,r.kt)("h3",{id:"running-the-transform"},"Running the transform"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'transformers:\n  - type: "custom_transform_example_alias"\n    config:\n      owners_json: "<path_to_owners_json>" # the JSON file mentioned at the start\n')),(0,r.kt)("p",null,"After running ",(0,r.kt)("inlineCode",{parentName:"p"},"datahub ingest -c <path_to_recipe>"),", our MCEs will now have the following owners appended:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'"owners": [\n    {\n        "owner": "urn:li:corpuser:athos",\n        "type": "DATAOWNER",\n        "source": null\n    },\n    {\n        "owner": "urn:li:corpuser:porthos",\n        "type": "DATAOWNER",\n        "source": null\n    },\n    {\n        "owner": "urn:li:corpuser:aramis",\n        "type": "DATAOWNER",\n        "source": null\n    },\n    {\n        "owner": "urn:li:corpGroup:the_three_musketeers",\n        "type": "DATAOWNER",\n        "source": null\n    },\n    // ...and any additional owners\n],\n')),(0,r.kt)("p",null,"All the files for this tutorial may be found ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/datahub-project/datahub/blob/master/metadata-ingestion/examples/transforms/"},"here"),"."))}m.isMDXComponent=!0}}]);